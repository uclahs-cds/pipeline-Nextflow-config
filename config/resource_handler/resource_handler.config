import groovy.json.JsonSlurper
import nextflow.util.SysHelper

includeConfig "../schema/custom_schema_types.config"
includeConfig "../methods/common_methods.config"

class SystemResources {
    private Map resource_limits = [
        'cpus': [
            'type': java.lang.Integer,
            'min': 1,
            'max': SysHelper.getAvailCpus()
        ],
        'memory': [
            'type': nextflow.util.MemoryUnit,
            'min': 1.MB,
            'max': SysHelper.getAvailMemory()
        ],
        'time': [
            'type': nextflow.util.Duration,
            'min': 1.s,
            'max': 1000.d
        ]
    ]
    private String resource_profile = null

    SystemResources(Map params) {
        this.resource_limits.each { resource, resource_info ->
            ['min', 'max'].each { limit_end ->
                try {
                    if (params.containsKey("${limit_end}_${resource}" as String)) {
                        this.resource_limits[resource][limit_end] = params["${limit_end}_${resource}" as String].asType(his.resource_limits[resource]['type'])
                    }
                } catch (all) {
                    // Do nothing, let default value defined above take effect
                }
            }
        }

        this.identify_resource_profile()
    }

    Object check_limits(Object obj, String type) {
        return SystemResources.check_limits(obj, type, this.resource_limits[type]['min'], this.resource_limits[type]['max'])
    }

    static Object check_limits(Object obj, String type, Object min, Object max) {
        if (obj.compareTo(max) == 1) {
            return max
        } else if (obj.compareTo(min) == -1) {
            return min
        } else {
            return obj
        }
    }

    private void identify_resource_profile() {
         // Identify if available resources match F- or M-series nodes
         def cpus = this.resource_limits.cpus.max
         def memory = this.resource_limits.memory.max.toGiga()

         if (cpus >= (cpus * 2 * 0.9 - 1) && (cpus <= (cpus * 2))) {
             this.resource_profile = "f${cpus}"
         }

         if (cpus >= (cpus * 16 * 0.9 - 1) && (cpus <= (cpus * 16))) {
             this.resource_profile = "m${cpus}"
         }
    }

    Object resolve_resource_allocation(Map allocation, String type) {
        def min_raw = allocation['min'].asType(this.resource_limits[type]['type'])
        def max_raw = allocation['max'].asType(this.resource_limits[type]['type'])

        def min_allocation = this.check_limits(min_raw, type)
        def max_allocation = this.check_limits(max_raw, type)

        def requested_allocation = allocation.fraction * (this.resource_limits[type]['max'])

        return SystemResources.check_limits(requested_allocation, type, min_allocation, max_allocation)
    }

    String get_resource_profile_tag() {
        return this.resource_profile
    }
}

class PipelineAllocation {
    private SystemResources system_resources
    private File resource_json
    private String allocation_profile
    private Map processed_resources = [:]
    private Map raw_process_resources = [:]

    PipelineAllocation(Object resource_json, Object params) {
        this.system_resources = new SystemResources(params)
        this.resource_json = new File(resource_json)

        def json_slurper = new JsonSlurper()

        // TO-DO: Dump original for logging, keeping in class for now
        this.raw_process_resources = json_slurper.parse(this.resource_json)

        this.select_allocation_profile(params)

        assert this.raw_process_resources instanceof Map

        // TO-DO: Validate JSON is in expected format

        // Convert string memory units to memory unit
        this.processed_resources.each { process, allocations ->
            for (resource_type in ["cpus", "memory", "time"]) {
                if (allocations.containsKey(resource_type)) {
                    allocations[resource_type] = this.system_resources.resolve_resource_allocation(allocations[resource_type], resource_type)
                }
            }
        }
    }

    private void load_resource_profile(String profile_tag) {
        this.processed_resources = this.raw_process_resources[profile_tag]

        if (!this.processed_resources) {
            throw new Exception("   ### ERROR ###   Failed to find requested resource profile: `${profile_tag}`")
        }
    }

    private void select_allocation_profile(Map params) {
        String profile_tag = null

        // Try for user-given profile
        if (params.containsKey('resource_allocation_profile_tag') && params.resource_allocation_profile_tag) {
            profile_tag = params.resource_allocation_profile_tag
            this.load_resource_profile(profile_tag)
            return
        }

        // Try loading detected tag based on system resources
        profile_tag = this.system_resources.get_resource_profile_tag()

        if (profile_tag) {
            try {
                this.load_resource_profile(profile_tag)
            } catch (all) {
                // Continue to try loading `default` profile
            }
        }

        // Resort to loading `default` profile
        this.load_resource_profile('default')
    }

    // TO-DO: functionality to dump original loaded JSON to file for logging

    void update_base_allocation(String resource, String process, Object multiplier) {
        if (this.processed_resources.containsKey(process) && this.processed_resources[process].containsKey(resource)) {
            this.processed_resources[process][resource] = this.system_resources.check_limits(this.processed_resources[process][resource] * multiplier, resource)
        } else {
            System.out.println("   ### WARNING ### No base value found for resource `${resource}` for process `${process}`. Update will be skipped.")
        }
    }

    // Apply base resource updates
    void apply_base_updates(Map resource_updates) {
        resource_updates.each { resource, updates ->
            updates.each { processes, multiplier ->
                List processes_to_update = (processes instanceof String || processes instanceof GString) ? [processes] : processes

                if (processes_to_update == []) {
                    processes_to_update = this.processed_resources.keySet() as List
                }

                processes_to_update.each { process ->
                    this.update_base_allocation(resource, process, multiplier)
                }
            }
        }
    }

    // Check for retry definition and update entries


    void print_resources() {
        System.out.println(this.processed_resources)
    }
}

resource_handler {
    handle_resources = {Object resource_file, Map current_params=params ->
        // try {
        def allocation_handler = new PipelineAllocation(resource_file, current_params)
        // } catch (all) {
        //     System.out.println("ERR: ${all}")
        // }
        allocation_handler.print_resources()

        if (params.containsKey('base_resource_update') && params.base_resource_update) {
            allocation_handler.apply_base_updates(params.base_resource_update)
        }

        // allocation_handler.print_resources()

        System.out.println('here?')
    }
}
