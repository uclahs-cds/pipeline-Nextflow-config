import groovy.json.JsonSlurper

includeConfig "../schema/custom_schema_types.config"
includeConfig "../methods/common_methods.config"

class PipelineAllocation {
    private Map processed_resources = [:]
    private Map raw_process_resources = [:]
    private File resource_json

    def check_limits( Object obj, String type) {
        if (type == 'memory') {
            try {
                if (obj.compareTo(params.max_memory as nextflow.util.MemoryUnit) == 1)
                    return params.max_memory as nextflow.util.MemoryUnit
                else if (obj.compareTo(params.min_memory as nextflow.util.MemoryUnit) == -1)
                    return params.min_memory as nextflow.util.MemoryUnit
                else
                    return obj
            } catch (all) {
                System.out.println("   ### WARNING ###   Max memory '${params.max_memory}' or min memory '${params.min_memory}' is not valid! Using default value: $obj")
                return obj
            }
        } else if (type == 'time') {
            try {
                if (obj.compareTo(params.max_time as nextflow.util.Duration) == 1)
                    return params.max_time as nextflow.util.Duration
                else if (obj.compareTo(params.min_time as nextflow.util.Duration) == -1)
                    return params.min_time as nextflow.util.Duration
                else
                    return obj
            } catch (all) {
                System.out.println("   ### WARNING ###   Max time '${params.max_time}' or min time '${params.min_time}' is not valid! Using default value: $obj")
                return obj
            }
        } else if (type == 'cpus') {
            try {
                return Math.max( Math.min( obj as int, params.max_cpus as int ), params.min_cpus as int )
            } catch (all) {
                System.out.println("   ### WARNING ###   Max cpus '${params.max_cpus}' or min cpus '${params.min_cpus}' is not valid! Using default value: $obj")
                return obj
            }
        }
    }

    PipelineAllocation(Object resource_json) {
        this.resource_json = new File(resource_json)

        def json_slurper = new JsonSlurper()

        // TO-DO: Dump original for logging, keeping in class for now
        this.raw_process_resources = json_slurper.parse(this.resource_json)
        this.processed_resources = json_slurper.parse(this.resource_json)

        assert this.raw_process_resources instanceof Map

        // TO-DO: Validate JSON is in expected format

        // Convert string memory units to memory unit
        this.processed_resources.each { process, allocations ->
            if (allocations.containsKey('memory')) {
                allocations.memory = allocations.memory as nextflow.util.MemoryUnit
            }
        }
    }

    // TO-DO: functionality to dump original loaded JSON to file for logging

    void update_base_allocation(String resource, String process, Object multiplier) {
        if (this.processed_resources.containsKey(process) && this.processed_resources[process].containsKey(resource)) {
            System.out.println(this.processed_resources[process][resource])
            System.out.println(multiplier)
            this.processed_resources[process][resource] = this.check_limits(this.processed_resources[process][resource] * multiplier, resource)
        } else {
            System.out.println("   ### WARNING ### No base value found for resource `${resource}` for process `${process}`. Update will be skipped.")
        }
    }

    // Apply base resource updates
    void apply_base_updates(Map resource_updates) {
        resource_updates.each { resource, updates ->
            System.out.println(updates)
            updates.each { processes, multiplier ->
                List processes_to_update = (processes instanceof String || processes instanceof GString) ? [processes] : processes

                if (processes_to_update == []) {
                    processes_to_update = this.raw_process_resources.keySet() as List
                }

                processes_to_update.each { process ->
                    this.update_base_allocation(resource, process, multiplier)
                }
            }
        }
    }

    // Check for retry definition and update entries


    void print_resources() {
        System.out.println(this.processed_resources)
    }
}

resource_handler {
    handle_resources = {Object resource_file ->
        def allocation_handler = new PipelineAllocation(resource_file)
        allocation_handler.print_resources()

        if (params.containsKey('base_resource_update') && params.base_resource_update) {
            allocation_handler.apply_base_updates(params.base_resource_update)
        }

        allocation_handler.print_resources()
    }
}
