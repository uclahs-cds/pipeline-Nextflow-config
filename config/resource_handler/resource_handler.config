import groovy.json.JsonSlurper

includeConfig "../schema/custom_schema_types.config"
includeConfig "../methods/common_methods.config"

class SystemResources {
    private Map resource_limits = [
        'cpus': [
            'type': int,
            'min': 1,
            'max': Integer.MAX_VALUE
        ],
        'memory': [
            'type': nextflow.util.MemoryUnit,
            'min': 1.MB,
            'max': 1000.TB
        ],
        'time': [
            'type': nextflow.util.Duration,
            'min': 1.s,
            'max': 1000.d
        ]
    ]

    SystemResources(Map params) {
        this.resource_limits.each { resource, resource_info ->
            ['min', 'max'].each { limit_end ->
                try {
                    if (params.containsKey("${limit_end}_${resource}")) {
                        this.resource_limits[resource][limit_end] = (params["${limit_end}_${resource}"] as this.resource_limits[resource]['type'])
                    }
                } catch (all) {
                    // Do nothing, let default value defined above take effect
                }
            }
        }
    }

    Object check_limits(Object obj, String type) {
        if (obj.compareTo(this.resource_limits[type]['max']) == 1) {
            return this.resource_limits[type]['max']
        } else if (obj.compareTo(this.resource_limits[type]['min']) == -1) {
            return this.resource_limits[type]['min']
        } else {
            return obj
        }
    }
}

class PipelineAllocation {
    private SystemResources system_resources
    private Map processed_resources = [:]
    private Map raw_process_resources = [:]
    private File resource_json

    PipelineAllocation(Object resource_json, Object params) {
        this.system_resources = new SystemResources(params)
        this.resource_json = new File(resource_json)

        def json_slurper = new JsonSlurper()

        // TO-DO: Dump original for logging, keeping in class for now
        this.raw_process_resources = json_slurper.parse(this.resource_json)
        this.processed_resources = json_slurper.parse(this.resource_json)

        assert this.raw_process_resources instanceof Map

        // TO-DO: Validate JSON is in expected format

        // Convert string memory units to memory unit
        this.processed_resources.each { process, allocations ->
            if (allocations.containsKey('memory')) {
                allocations.memory = allocations.memory as nextflow.util.MemoryUnit
            }
        }
    }

    // TO-DO: functionality to dump original loaded JSON to file for logging

    void update_base_allocation(String resource, String process, Object multiplier) {
        if (this.processed_resources.containsKey(process) && this.processed_resources[process].containsKey(resource)) {
            this.processed_resources[process][resource] = this.system_resources.check_limits(this.processed_resources[process][resource] * multiplier, resource)
        } else {
            System.out.println("   ### WARNING ### No base value found for resource `${resource}` for process `${process}`. Update will be skipped.")
        }
    }

    // Apply base resource updates
    void apply_base_updates(Map resource_updates) {
        resource_updates.each { resource, updates ->
            updates.each { processes, multiplier ->
                List processes_to_update = (processes instanceof String || processes instanceof GString) ? [processes] : processes

                if (processes_to_update == []) {
                    processes_to_update = this.raw_process_resources.keySet() as List
                }

                processes_to_update.each { process ->
                    this.update_base_allocation(resource, process, multiplier)
                }
            }
        }
    }

    // Check for retry definition and update entries


    void print_resources() {
        System.out.println(this.processed_resources)
    }
}

resource_handler {
    handle_resources = {Object resource_file, Map current_params=params ->
        def allocation_handler = new PipelineAllocation(resource_file, current_params)
        allocation_handler.print_resources()

        if (params.containsKey('base_resource_update') && params.base_resource_update) {
            allocation_handler.apply_base_updates(params.base_resource_update)
        }

        allocation_handler.print_resources()

        System.out.println('here?')
    }
}
